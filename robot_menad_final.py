from robot import *
import math
import re


# NOTE TOURNOI:
# - pas de fichiers externes
# - pas d'env vars
# - 1 seule mémoire: self.memory (int)
# - tout le comportement est dans step (helpers internes)

class Robot_player(Robot):
    team_name = "MenadTeam-NN+BRAIT"

    # Mets ici tes infos si demandé par le sujet:
    # noms_prenoms = "Menad ACHERAIOU"
    # no_etudiant = "..."

    def __init__(self, x, y, theta, name="n/a", team="A"):
        super().__init__(x, y, theta, name=name, team=team)
        self.memory = 0
        m = re.search(r"menad_(\d+)", str(self.name))
        self.idx = int(m.group(1)) if m else (self.id - 1)

    def step(self, sensors, sensor_view=None, sensor_robot=None, sensor_team=None):
        # ----------------------------
        # Constantes capteurs
        # ----------------------------
        F, FL, L, RL, RE, RR, R, FR = 0, 1, 2, 3, 4, 5, 6, 7
        VIEW_NONE, VIEW_WALL, VIEW_ROBOT = 0, 1, 2

        # ----------------------------
        # Hyperparams NN
        # ----------------------------
        NUM_INPUTS = 34
        HIDDEN = 8
        NUM_OUTPUTS = 2  # t, r

        # ----------------------------
        # Génomes EMBED (best_genomes.json)
        # ----------------------------
        genomes = {
            "open": {
                "0": [0.22458149026042265, -0.7953802126371169, 1.2470627039963107, 0.5388851029023143,
                      1.0735470648628225, 0.039896137061665726, -0.03226016061076947, -0.054654284114955154,
                      -0.4154877473377442, -0.686339350051467, 0.8917201432696479, 0.712545437798266, 1.097554151866188,
                      -0.3072852646606929, 0.7331660356696517, 0.3067106871370912, -0.11918852418933293,
                      -0.9764382518974736, -0.6651475803461985, -0.08740292741467282, -0.8291995531351596,
                      0.8830018748293574, 0.041156371025741906, -0.5056648638481552, 1.3071871860466493,
                      1.3236740126592756, 0.2976762671098168, -0.8129327387400036, 0.09130831079080526,
                      -0.08207866893138024, 0.12044060477676712, 1.3781075766256203, -0.48918854968321346,
                      0.9821718703001878, 0.14979029126240534, -0.727187828010445, 0.9124072626256383,
                      -0.01434966928056422, -0.06375542412743865, -0.4863241664047522, -0.4493058203581144,
                      0.5968232635664366, -0.2679243105944925, -0.21721628370643187, -0.0038008508674112207,
                      -0.021186486419038836, 0.25210560344313493, 0.9256691442129787, 0.3827167725162106,
                      1.4725727329314053, -0.7206283971756229, 0.05412662097775747, -1.0112576555675803,
                      0.5271004376366932, 0.6274275044515794, -0.6183411814048598, 0.03995258329411653,
                      1.6953956081736297, 1.4716005726883215, 0.555887599698769, 0.43497057350780327,
                      -0.8824191037000356, -0.7102135529584419, -0.10325763424780102, 1.4546604492687085,
                      -0.6871206360257568, -0.5353072504339744, -1.00968262544168, -0.6991228599927826,
                      0.2491363257585947, -0.08720520221222275, -0.3364136944938395, -0.22455806507060455,
                      0.6980476044952207, -0.4985432703169606, 0.6554920051358631, -0.7136351979794933,
                      0.6938348910710915, 0.8518260157113918, 1.2175855965907825, 0.22686494446859345,
                      0.26000047442366075, -0.008584696421238602, 1.2356491873039752, -0.13651987038378155,
                      1.7503725513369432, 1.055161529054449, -0.10966956957320217, -0.5905176415366662,
                      0.4720017092074376, 0.8310889071776537, -0.6944970529018627, -0.0013032448646204953,
                      0.5151823536657352, 0.48248028596859655, -1.2053946287796666, 0.4612925648808912,
                      0.5941376627696078, -0.11849616808932877, 1.6775801847736849, -0.8237001893815447,
                      0.9431267156522404, -0.006257922067130495, -0.4737122298661865, 0.024111970816119876,
                      1.1167414741803936, -1.2708227967802215, 0.3771956435245226, -0.8805962747895266,
                      0.013413125729583954, 0.8188975175435977, 1.008881099036945, -1.3043857756893202,
                      -1.3307154956481302, 1.0065125900947516, 0.4114357182429017, -0.847592328472009,
                      0.9056997477376394, 0.5014477451382278, -0.4213955517990765, -0.3541593820252271,
                      0.8408000438283957, 0.6405122676829267, -0.5369936819962209, 0.9470415809681985,
                      1.2375800910026964, 0.2737131046007307, -0.11292688954272331, 0.5275616943592931,
                      -1.897633642698594, 1.0184307031135644, 1.5290745307268476, -0.31423415814437855,
                      0.26910659901882006, 0.1080763213103128, 0.38062740864619093, -0.1711301579830666,
                      -0.4592747577016146, 1.1185425322048101, 0.6119334939016058, 0.06996633202911734,
                      0.24078330559826286, -0.16344932353137298, 0.5685417872686374, 0.16984742748993695,
                      -0.005597734641823768, -0.17091030526006593, 0.3429513697979275, 0.40454247362913803,
                      -0.78295480316155, 1.0625617052842011, -0.2716443700842702, 0.4440774393699911,
                      -0.7265081343305586, 0.8681310302914531, -0.20895325077811952, 0.5154332977320665,
                      -0.23898873715152735, 0.8228654144551836, 1.137404835314037, 0.03688259951194822,
                      1.2646594362850554, -0.42358035354990886, -1.7399516692102115, -0.6212737960535257,
                      0.04024420703830911, -0.13211946776335193, 0.18602643389923418, 0.4392081162862147,
                      1.0923128184064113, 0.6629080382323921, -0.9734405338375635, -0.9069636132016539,
                      -0.5236614157419769, 0.6484114255892706, -0.5195819103989932, 0.9173655948528914,
                      -0.056241605824226375, -0.5242723235322794, 1.319632013867662, -1.5455267100700438,
                      1.1451026522893593, -0.301959781664001, 1.1362401410107406, 0.23010506095739944,
                      -0.5408302940421572, -0.28340250732918093, -0.12731941712932077, 0.6801967173616706,
                      0.3372596951964903, 1.3582091142735107, -1.284078528031974, -0.4963074922438678,
                      0.8870894824667187, 0.9555289500476488, 0.9434342425380176, -0.24916352981361972,
                      -0.989531061594056, 0.3831146214114107, -0.5858133546186478, 0.5614389129719691,
                      -0.020420010072540212, 0.1997631449624207, 0.9588415180969658, 0.5009228560220622,
                      -0.2445941479088813, -0.06746336988701533, 0.09429933636015225, -0.03520898798933904,
                      -0.18101694598565432, 0.05063620464237151, -0.9539005627876491, -0.36101513990236467,
                      0.39191236122888984, -0.223821193246067, -0.26426970132388894, 0.24944034610445728,
                      -0.3011389726505531, -0.8096449729163063, -0.03657271675082411, -0.5637235384403327,
                      0.05523181528454103, 0.2673692500122473, 0.29424547455949557, -0.1062515527763922,
                      -1.0334807642020603, -0.9248345271473032, -0.6801059234589077, 0.13278943811249339,
                      -0.5343580874391431, 0.8221607125525359, 0.3165667437368901, 0.3938445951186922,
                      0.5612081165347176, -0.870515928209473, -0.36008074495980724, 0.4905174826028058,
                      -0.4030810986142896, 1.1808317407954658, 0.26404238624263254, 0.09025231469982921,
                      -0.429655247680687, 0.9309978890769366, 0.6362119811690404, -1.0072556253491403,
                      0.2993494698312139, 0.8586057064014264, -1.712532638126679, -1.0523703471782353,
                      -0.4635410792297006, -0.20710059167975242, 0.14122871929092976, 1.2069521890518122,
                      1.1270184785772488, 0.42629300747627075, 0.3224853121560127, 1.0657463134462366,
                      0.6943448739532104, -1.1811804379928337, -0.06295716314608008, 1.535602968910468,
                      -0.7515468305074449, 0.5173341346904566, 1.188180355100389, 0.3314008612890645,
                      0.02809146376951671, -0.688047051628471, 0.6025076976084452, 1.0883605104921237,
                      -0.29862891497552946, -0.4412549434640285, 1.0160252842278523, 0.4906875587715236,
                      0.5128911778407361, 1.2546766501022402, -0.20884120430866523, -0.7744940806060673,
                      0.4340555901643121, 0.28525491073298115, 1.1676898080059215, 0.6689693350607111,
                      0.15614427751855417, 0.2629372343640808, 0.01214865561579001, -0.2614652574289824,
                      0.8372048462262167, 0.1649325080221417, 0.09948428115319138, 1.0362385713701583,
                      -0.2578212542933847, 1.041086194182628, 0.9114967340273361, -0.15833589188653402,
                      -1.3489513739529966, -0.6344423850378484, 0.252454104230984, 0.09556603359334195,
                      1.6287630233626267],
            },
            "maze": {
                "0": [0.286151409031802, -0.6358999398173388, -1.0352898915032227, -0.03414948248941059,
                      -0.3419769902106046, -0.2235979859339931, -0.5451103065958159, 0.16041161444102486,
                      -0.46941669367614, -0.7401673033784733, 0.9639629074023635, 0.5014171407160741,
                      0.2710842480769891, 0.256151262812272, 0.567970751661234, -1.0848421195146705, 0.341065242241971,
                      -0.8029495031957208, -1.7951359113947114, -0.1827056183348392, 0.4134115600970159,
                      -0.06525505898408734, -1.1631718968894813, -0.20572770336009152, 0.3737859949483174,
                      0.7496266174616127, -1.3825578734557629, 1.6974195927850337, 0.12464661697078741,
                      1.1452969025390807, -1.809381647810108, 0.10617737133642285, 0.4655035088658749,
                      0.5010879807872526, -0.4456733951175852, 0.09803604236870264, -1.1165430529811142,
                      -0.3627308433699917, 0.17089847735319164, -1.5181503723696637, 0.20624276907814074,
                      0.1477557617488316, 0.1018844422930433, 0.348239951065418, 0.4282041729367959,
                      -0.5007199785218782, 1.0172507063773484, 0.1643494543542258, 1.7209792826352495,
                      1.6102942234669937, -0.4265327564623164, 0.848984723006895, 0.35007696818941886,
                      0.11457817521390452, -0.9628036987669476, 0.6695054702475146, -0.12596096536982393,
                      0.923458901057598, 0.1755102819801759, 1.2055578253787402, -1.6478247338648784,
                      0.5257894681941457, 0.23554966006499123, -0.07936558762917588, 0.4427474429865703,
                      -0.47671347222629173, 0.3828795731145714, 0.13631818159490727, 0.8477758508568912,
                      -0.9385462472793381, -0.5882342637003803, 0.723838876905708, 0.7347140186038799,
                      -1.5489151399051053, -0.8491946916902585, -1.4832070757995905, -1.153263865441235,
                      1.2864934376144697, -1.3899894114018914, 0.8295090363070016, -0.8527458424853578,
                      1.1177926058942833, -0.8739564208868646, -0.7685298879542806, 0.26538446765794543,
                      0.04364284947973755, -0.5574493652015571, -1.0487084366267656, -0.4560823390771114,
                      -0.6346788573455262, -0.050793852390964865, 1.3229189594753588, -0.626273641640572,
                      -0.14582093944215715, -1.396138010470127, -1.8723286669196668, -0.26732836059284515,
                      -0.23095257612903045, 0.990577102343992, -1.1760313085527498, 0.38093907149303075,
                      0.788709054783571, -0.5367850381955788, -0.1986778647716051, 0.4371012557016407,
                      0.7068637278631205, 0.35800930258640806, -0.4991670139056494, -0.00014985042249445607,
                      -0.1433402355161445, 1.5065075261987428, 0.21838293214045634, -0.17520562771254586,
                      -0.6863047383214366, 0.07624441688683715, -0.14167751439564735, 0.9741160978047113,
                      1.3647999465845762, 0.5650902106094543, 1.6144115087859658, -0.23134705103587938,
                      -0.6799593385163198, 1.6438788250737382, -0.06750663635572315, -0.479603635188443,
                      0.25228953465205284, -1.1703689684301863, 0.057433058903322246, -0.1870084117337643,
                      0.44787582336004683, -0.3701821966915648, -0.3700384079222475, 0.10607929080524107,
                      -0.8794236714902937, -0.6755658431691046, 0.1562332662414581, -0.626804755260421,
                      0.4600169734452545, -0.5532739149221584, 0.6424648862940359, -0.938248532408585,
                      1.6276171086399427, 0.013430964930855067, -0.6750350635076093, -1.5183885883094563,
                      -0.04897112865046597, -1.0651453896300989, 1.7712763834015506, 0.026409727571568273,
                      0.08343158228184189, 0.06543625004206749, -0.10688631452745961, -0.09546743246879907,
                      -0.847001986545697, -1.3521690413309067, -1.041834102008524, -0.3599143024748964,
                      -0.0951571707028141, 0.4561046909456344, 0.17565028596678844, -0.6001422772074688,
                      0.5863058336193541, -0.8016758246997268, -0.1910890542833798, 0.3447171444763168,
                      -0.2668900470943374, 0.7787844794035628, -0.1296837500986023, -1.0868509921626026,
                      -0.8582217248268169, 1.2192823404310695, 0.1220446076560038, 1.2470335182939862,
                      -0.11247103659758359, 1.398636509822576, -0.8223827925502498, -0.5057473453112877, -2.0,
                      1.4070195632418163, 1.52193528138019, -0.8488618922172887, -1.8990930295568567,
                      -0.07635637156612239, -0.2862205703222797, 0.5601780358600023, -0.1099749538224607,
                      0.9529125833096165, -0.9847344434090972, -0.191516546643698, 0.041248009363133435,
                      0.583117283553085, -0.6442884358042151, -0.2328404620780467, -0.08183531906434034,
                      0.07695521189887874, 0.4441855430996582, 0.5304089202620491, -0.22064936986034434,
                      0.6328565515649591, -0.086401919778204, 0.44916834374781156, 0.2132267450806946,
                      -1.9231238212452648, -0.4719301311983726, 0.08362614929778518, 0.8966858490465519,
                      0.6331233030680494, -0.699910786427463, -0.6893640701843455, -0.4250133952517266,
                      -0.2743829428778949, -1.1757212763555938, 0.8748454408249527, -0.4124116054025968,
                      -1.3383467117448689, -0.1488616990748457, -0.8816793536424754, -0.4631388960345451,
                      -0.2713313895133229, -0.3260712604655809, 0.5251513162523208, -1.1028508382587034,
                      0.8579167229490903, -0.7490842990430507, -0.696702739527799, -0.26107898976739424,
                      -0.7850552532635358, 0.6807684369323344, -0.882646623648071, 0.3605478791575123,
                      0.7793534790337602, 0.033301032691472124, -0.25874692876018324, 0.861391034207825,
                      0.47705934194195654, 1.3093762306666894, -1.3216467539243715, 0.43086645335228135,
                      0.7477551567273699, -0.749047388500624, 1.204427973169903, 0.5134099652004901,
                      -0.1855678454897892, 0.13308427700926545, 0.647969697293248, -1.672793929596418,
                      -0.05405228194048744, -0.37909036608590413, 1.5649967707155494, 0.144138341421916,
                      0.9076609185760457, 0.4448082517268323, -0.0370509545972736, 0.013247503467973487,
                      -1.1732566002573992, 1.314863745554782, -0.1210151773420903, 0.336382386872748,
                      -1.321926856555358, 0.002654659552206961, -1.542714625024077, -1.2197856178704163,
                      -0.261677899959535, 0.5118190458724947, 1.8287855012459182, -0.6555849195010338,
                      0.6821174378565596, -0.9203088232749466, -0.1655510564980647, -1.4900783506347133,
                      0.625929894096124, -1.1378150707188008, 1.068318073110863, 0.3314723569007249, 0.4591585991858841,
                      1.282173031069311, 0.40158165762938247, -1.9202198011325324, -0.4060088093197204,
                      0.28525178038431787, -1.0366026004406907, 1.4157196051008056, -0.9017661296652928,
                      1.4471614757172135, -0.2147412042591259, 1.2760118636548117, -0.1284029164185676,
                      -1.2560968827774566, 0.9922473462822659, -0.7591572663916595, 1.206872078040512,
                      1.7151768740678166, -1.0013793643788058, -0.06812228338939354, -0.9479067866901776,
                      -0.7833858239026417, -0.6486897669452255, 0.3975711371896073],
            }
        }

        # ----------------------------
        # Helpers internes
        # ----------------------------
        def clamp(x, a=-1.0, b=1.0):
            return max(a, min(b, float(x)))

        def is_ally(i):
            return sensor_view[i] == VIEW_ROBOT and sensor_team[i] == self.team

        def is_enemy(i):
            return sensor_view[i] == VIEW_ROBOT and sensor_team[i] != self.team and sensor_team[i] != "n/a"

        # Memory simple: mode*1000 + ctx*10 + esc_dir + esc_timer (2 digits max 99)
        def mem_unpack(mem):
            mem = int(mem) if mem is not None else 0
            mode = (mem // 100000) % 10  # 0 ou 1
            ctx = (mem // 1000) % 100  # 0..99
            esc_dir = (mem // 100) % 10  # 0 ou 1
            esc_timer = mem % 100  # 0..99
            mode = 0 if mode <= 0 else 1
            return mode, ctx, esc_dir, esc_timer

        def mem_pack(mode, ctx, esc_dir, esc_timer):
            mode = 0 if mode <= 0 else 1
            ctx = max(0, min(99, int(ctx)))
            esc_dir = 1 if esc_dir else 0
            esc_timer = max(0, min(99, int(esc_timer)))
            return mode * 100000 + ctx * 1000 + esc_dir * 100 + esc_timer

        def count_close_walls(thr=0.26):
            c = 0
            for i in range(8):
                if sensor_view[i] == VIEW_WALL and float(sensors[i]) < thr:
                    c += 1
            return c

        def detect_corridor():
            left_close = (sensor_view[L] == VIEW_WALL and sensors[L] < 0.35) or \
                         (sensor_view[FL] == VIEW_WALL and sensors[FL] < 0.30)
            right_close = (sensor_view[R] == VIEW_WALL and sensors[R] < 0.35) or \
                          (sensor_view[FR] == VIEW_WALL and sensors[FR] < 0.30)
            return left_close and right_close

        # NN forward 34->8->2, relu puis tanh
        def nn_forward(genome, x):
            total_params = (NUM_INPUTS * HIDDEN + HIDDEN) + (HIDDEN * NUM_OUTPUTS + NUM_OUTPUTS)
            g = genome
            if len(g) < total_params:
                g = g + [0.0] * (total_params - len(g))
            elif len(g) > total_params:
                g = g[:total_params]

            idxp = 0
            W1 = []
            for _ in range(HIDDEN):
                W1.append(g[idxp:idxp + NUM_INPUTS])
                idxp += NUM_INPUTS
            b1 = g[idxp:idxp + HIDDEN]
            idxp += HIDDEN
            W2 = []
            for _ in range(NUM_OUTPUTS):
                W2.append(g[idxp:idxp + HIDDEN])
                idxp += HIDDEN
            b2 = g[idxp:idxp + NUM_OUTPUTS]

            h = []
            for j in range(HIDDEN):
                s = b1[j]
                w = W1[j]
                for i in range(NUM_INPUTS):
                    s += w[i] * x[i]
                h.append(s if s > 0 else 0.0)

            out = []
            for k in range(NUM_OUTPUTS):
                s = b2[k]
                w = W2[k]
                for j in range(HIDDEN):
                    s += w[j] * h[j]
                out.append(math.tanh(s))
            return out

        def nn_inputs34(ctx_norm, role):
            x = []
            # 8 distances
            for i in range(8):
                x.append(min(1.0, float(sensors[i])))
            # 8 walls
            for i in range(8):
                x.append(1.0 if sensor_view[i] == VIEW_WALL else 0.0)
            # 8 allies
            for i in range(8):
                x.append(1.0 if is_ally(i) else 0.0)
            # 8 enemies
            for i in range(8):
                x.append(1.0 if is_enemy(i) else 0.0)
            # ctx + role
            x.append(float(ctx_norm))
            x.append(float(role))
            return x

        # Escape anti-blocage simple
        def do_escape_if_needed(esc_dir, esc_timer):
            if esc_timer > 0:
                esc_timer -= 1
                rot = +0.85 if esc_dir == 0 else -0.85
                return True, (-0.50, rot), esc_dir, esc_timer

            wall_hard = (sensor_view[F] == VIEW_WALL and sensors[F] < 0.14) or \
                        (sensor_view[FL] == VIEW_WALL and sensors[FL] < 0.12) or \
                        (sensor_view[FR] == VIEW_WALL and sensors[FR] < 0.12)

            ally_hard = (is_ally(F) and sensors[F] < 0.18) or \
                        (is_ally(FL) and sensors[FL] < 0.16) or \
                        (is_ally(FR) and sensors[FR] < 0.16)

            if wall_hard or ally_hard:
                esc_dir = 0 if (self.idx % 2 == 0) else 1
                esc_timer = 12
                rot = +0.85 if esc_dir == 0 else -0.85
                return True, (-0.50, rot), esc_dir, esc_timer

            return False, (0.0, 0.0), esc_dir, esc_timer

        # WALL FOLLOWER robuste pour robots 1 et 2
        def wall_follower(follow_right):
            """
            follow_right: True = suit le mur de droite, False = suit le mur de gauche
            """
            f = float(sensors[F])
            fl = float(sensors[FL])
            fr = float(sensors[FR])
            l = float(sensors[L])
            r = float(sensors[R])
            rl = float(sensors[RL])
            rr = float(sensors[RR])

            # RÈGLE 1: Mur devant proche -> TOURNER FORT du côté opposé au mur suivi
            if sensor_view[F] == VIEW_WALL and f < 0.30:
                if follow_right:
                    # Suit droite -> tourne à GAUCHE quand bloqué
                    return (0.40, +0.95, 0, 0)
                else:
                    # Suit gauche -> tourne à DROITE quand bloqué
                    return (0.40, -0.95, 0, 0)

            # Coin détecté (mur devant + mur sur le côté)
            if f < 0.35:
                if follow_right and sensor_view[FR] == VIEW_WALL and fr < 0.28:
                    return (0.35, +0.90, 0, 0)  # Tourne à gauche
                elif not follow_right and sensor_view[FL] == VIEW_WALL and fl < 0.28:
                    return (0.35, -0.90, 0, 0)  # Tourne à droite

            # RÈGLE 2: Suivre le mur à distance constante
            if follow_right:
                # Suit le mur de DROITE
                target_dist = 0.30

                # Trouver la distance au mur de droite
                if sensor_view[R] == VIEW_WALL:
                    wall_dist = r
                elif sensor_view[FR] == VIEW_WALL:
                    wall_dist = fr
                elif sensor_view[RR] == VIEW_WALL:
                    wall_dist = rr
                else:
                    # Pas de mur à droite -> tourner à DROITE pour chercher un mur
                    return (0.85, -0.40, 0, 0)

                # Ajuster pour rester à distance constante
                error = wall_dist - target_dist

                if wall_dist < 0.18:
                    # Trop proche du mur -> s'éloigner (tourner à gauche)
                    return (0.75, +0.50, 0, 0)
                elif wall_dist > 0.50:
                    # Trop loin du mur -> se rapprocher (tourner à droite)
                    return (0.85, -0.35, 0, 0)
                else:
                    # Distance OK -> avancer avec correction douce
                    rot = clamp(-1.2 * error, -0.25, 0.25)
                    return (0.90, rot, 0, 0)

            else:
                # Suit le mur de GAUCHE
                target_dist = 0.30

                # Trouver la distance au mur de gauche
                if sensor_view[L] == VIEW_WALL:
                    wall_dist = l
                elif sensor_view[FL] == VIEW_WALL:
                    wall_dist = fl
                elif sensor_view[RL] == VIEW_WALL:
                    wall_dist = rl
                else:
                    # Pas de mur à gauche -> tourner à GAUCHE pour chercher un mur
                    return (0.85, +0.40, 0, 0)

                # Ajuster pour rester à distance constante
                error = wall_dist - target_dist

                if wall_dist < 0.18:
                    # Trop proche du mur -> s'éloigner (tourner à droite)
                    return (0.75, -0.50, 0, 0)
                elif wall_dist > 0.50:
                    # Trop loin du mur -> se rapprocher (tourner à gauche)
                    return (0.85, +0.35, 0, 0)
                else:
                    # Distance OK -> avancer avec correction douce
                    rot = clamp(+1.2 * error, -0.25, 0.25)
                    return (0.90, rot, 0, 0)

        # Hunter (robot 3)
        def hunter():
            STEER = {F: 0.0, FL: +0.6, L: +0.9, RL: +1.0, RE: 0.0, RR: -1.0, R: -0.9, FR: -0.6}

            # Anti-corner
            front_wall = (sensor_view[F] == VIEW_WALL and sensors[F] < 0.55)
            fl_wall = (sensor_view[FL] == VIEW_WALL and sensors[FL] < 0.35)
            fr_wall = (sensor_view[FR] == VIEW_WALL and sensors[FR] < 0.35)
            if front_wall and (fl_wall or fr_wall):
                if fl_wall and not fr_wall:
                    return -0.35, -0.35
                if fr_wall and not fl_wall:
                    return -0.35, +0.35
                return -0.35, (+0.35 if (self.idx % 2 == 0) else -0.35)

            # Anti-wall early à haute vitesse
            if sensor_view[F] == VIEW_WALL and sensors[F] < 0.75:
                left_free = sensors[FL] if sensor_view[FL] != VIEW_WALL else 0.0
                right_free = sensors[FR] if sensor_view[FR] != VIEW_WALL else 0.0
                t = 0.85
                r = -0.18 if right_free > left_free else +0.18
                return t, r

            # Chase
            best_i, best_d = None, 1.0
            for i in range(8):
                if is_enemy(i) and sensors[i] < best_d:
                    best_d, best_i = sensors[i], i

            if best_i is not None:
                r = STEER.get(best_i, 0.0)
                if best_d > 0.45:
                    t = 0.95
                elif best_d > 0.25:
                    t = 0.75
                else:
                    t = 0.50
                return clamp(t), clamp(r)

            # Explore rapide
            t = 1.00
            r = +0.08 if (self.idx % 2 == 0) else -0.08

            if sensor_view[L] == VIEW_WALL and sensors[L] < 0.28:
                r = -0.16
            elif sensor_view[R] == VIEW_WALL and sensors[R] < 0.28:
                r = +0.16

            if sensor_view[FL] == VIEW_WALL and sensors[FL] < 0.35:
                r = -0.16
            if sensor_view[FR] == VIEW_WALL and sensors[FR] < 0.35:
                r = +0.16

            if (sensor_view[L] == VIEW_WALL and sensors[L] < 0.22) and \
                    (sensor_view[R] == VIEW_WALL and sensors[R] < 0.22):
                t = 0.85

            return clamp(t), clamp(r)

        # Update mode/ctx
        def update_mode_ctx(mode, ctx):
            many = (count_close_walls(thr=0.26) >= 3)
            corridor = detect_corridor()
            front_hit = (sensor_view[F] == VIEW_WALL and sensors[F] < 0.14)

            if front_hit:
                ctx = min(99, ctx + 7)
            elif many or corridor:
                ctx = min(99, ctx + 2)
            else:
                ctx = max(0, ctx - 1)

            # Hysteresis
            if mode == 0 and ctx >= 60:
                mode = 1
            elif mode == 1 and ctx <= 40:
                mode = 0
            return mode, ctx

        # ----------------------------
        # Sécurité équipe
        # ----------------------------
        if self.team != "A":
            return 0.0, 0.0, False

        # ----------------------------
        # Lecture mémoire
        # ----------------------------
        mode, ctx, esc_dir, esc_timer = mem_unpack(self.memory)
        mode, ctx = update_mode_ctx(mode, ctx)
        ctx_norm = ctx / 99.0

        # ----------------------------
        # Escape global
        # ----------------------------
        esc, (t, r), esc_dir, esc_timer = do_escape_if_needed(esc_dir, esc_timer)
        if esc:
            self.memory = mem_pack(mode, ctx, esc_dir, esc_timer)
            return t, r, False

        # ----------------------------
        # Comportements par robot
        # ----------------------------

        # Robot 0: Neural Network
        if self.idx == 0:
            role = 0.0
            x = nn_inputs34(ctx_norm, role)
            key_mode = "maze" if mode == 1 else "open"
            g = genomes[key_mode][str(self.idx)]
            out = nn_forward(g, x)
            t_raw, r_raw = out[0], out[1]
            t = (t_raw + 1.0) * 0.5
            t = max(0.15, min(1.0, t))
            r = clamp(r_raw, -0.35, 0.35)
            self.memory = mem_pack(mode, ctx, esc_dir, esc_timer)
            return clamp(t), clamp(r), False

        # Robots 1 et 2: Maze experts avec wall-following
        elif self.idx == 1 or self.idx == 2:
            # Robot 1 suit le mur de droite, Robot 2 suit le mur de gauche
            follow_right = (self.idx == 1)
            t, r, esc_dir, esc_timer = wall_follower(follow_right)
            self.memory = mem_pack(mode, ctx, esc_dir, esc_timer)
            return clamp(t), clamp(r), False

        # Robot 3: Hunter
        else:
            t, r = hunter()
            self.memory = mem_pack(mode, ctx, esc_dir, esc_timer)
            return clamp(t), clamp(r), False